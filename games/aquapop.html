<html lang=en>
<body bgcolor=black onkeydown=keydown[event.keyCode]=lastnow onkeyup=keydown[event.keyCode]=0>
<canvas id=canvas width=640 height=480></canvas>
<script>
context = canvas.getContext`2d`;

lastnow =
level =
life =
playervx =
slowuntil =
multiuntil =
graceuntil = 0;

playerx = 320;

keydown = {};
objs = harpoons = []; // doesn't change when level=0 and reset at start, so can be shared

drawtext = (x, y, sz, fill, text, filter/*=undefined*/) => {
    context.font = sz + 'px a';
    context.filter = filter; // nothing happens if undefined
    context.fillStyle = fill;
    context.fillText(text, x, y);
    context.filter = 'none';
};

drawobj = ([x, y, vx, , kind, text]) => {
    context.save();
    vx > 0 && context.transform(-1, 0, 0, 1, x*2, 0);
    sz = (kind > 0) * kind * 20 + 20;
    filter = '';
    if (text)
        life ? filter = 'drop-shadow(0px 0px 10px white) drop-shadow(2px 2px 2px white)' : 0,
        lastnow < multiuntil ? filter += ' drop-shadow(2px 4px 6px orange' : 0;
    drawtext(
        x, y, sz, 0,
        text || 'ü¶êüê°üê†üêüüêôü¶ëüê¨üê≥üêãü¶à‚è∞‚Äã‚≠ê‚Äãüíù'.substr(kind % 10 * 2, 2),
        filter);
    context.restore();
};

tick = now => {
    now /= 1e3;
    requestAnimationFrame(tick); // update can fail, so we must enqueue beforehand

    // our collision check is primitive, so we need to ensure the minimum frame rate
    elapsed = now - lastnow;
    if (elapsed > 100) elapsed = 100;
    harpoonshot = keydown[32] == lastnow;
    lastnow = now;

    if (level || keydown[13]) {
        // enter to start (also actual reset)
        if (!level) {
            canvas.style.filter = '';
            life = playervx = slowuntil = multiuntil = graceuntil = 0;
            playerx = 320;
            objs = [];
            harpoons = [];
            keydown = {}; // no pre-press advantage :-)
        }

        // if all remaining objects are bonuses (or none)
        if (objs.every(obj => obj[4] < 0)) {
            template = [
                [[0, 1]],
                [[1, 1]],
                [[0, 2], [2, 1]],
                [[2, 3]],
                [[1, 4], [3, 1]],
                [[3, 2]],
                [[0, 9]],
            ][level % 7];
            for ([kind, count] of template)
                for (
                    i = count++;
                    i;
                    objs.push([
                        640 * i-- / count,
                        -~kind * 10,
                        100,
                        0,
                        kind + level / 7 | 0,
                    ]));
            ++level;
        }

        playervx = (!keydown[37] - !keydown[39]) * 300;
        playerx += playervx * elapsed;
        if (playerx < 20) playerx = 20;
        if (playerx > 620) playerx = 620;

        // shot harpoon if no other harpoon exists or multi is enabled
        if (harpoonshot && (!harpoons[0] || now < multiuntil))
            harpoons.push([playerx + (playervx > 0 ? 6 : -6), 410]);

        objelapsed = elapsed;
        if (now < slowuntil) objelapsed *= .3;
        newobjs = [];
        objs = objs.filter(obj => {
            ([x, y, vx, vy, kind] = obj);
            vy += 600 * objelapsed;
            sz = (kind > 0) * kind * 10 + 10; // so that (x, y) +/- sz is occupied by obj

            // against harpoons (for ordinary objs)
            if (kind >= 0) {
                lextent = x - sz + (vx < 0) * vx * objelapsed;
                rextent = x + sz + (vx > 0) * vx * objelapsed;
                for (harpoon of harpoons) {
                    ([hx, htop, used] = harpoon);
                    if (!used && y > htop && lextent < hx && hx < rextent) {
                        // larger obj generates a pair of smaller objs when popped
                        if (kind)
                            newobjs.push(
                                [x, y, vx, -350, kind - 1],
                                [x, y, -vx, -350, kind - 1]);
                        // 10% chance of additional bonus objs
                        rand = Math.random();
                        if (rand < .1)
                            newobjs.push([x, y, vx, vy, rand * 30 - 4 | 0]);
                        harpoon[2] = 1; // so that harpoon will be cleared off
                        return; // and this elimiates the original obj
                    }
                }
            }

            // against player
            if ((x - playerx)**2 + (y - 390)**2 < sz**2 + 20**2) {
                if (kind < 0) {
                    kind %= 10;
                    ++kind ? // kind != -1
                        ++kind ? // kind != -1 or -2
                            slowuntil = now + 10 : // kind == -3
                            multiuntil = now + 10 : // kind == -2
                        life = 1; // kind == -1
                    return;
                }
                // game is over when life was already 0 and grace period expires
                if (life) {
                    life = 0;
                    graceuntil = now + 1;
                } else if (now > graceuntil) {
                    // we can't reset right now, as drawing still happens every frame
                    // the actual reset will happen on enter
                    canvas.style.filter = 'invert(1';
                    level = 0;
                    throw 1; // this "tick" can't be continued
                }
            }

            x += vx * objelapsed;
            y += vy * objelapsed;

            // against ground
            if (y > 410 - sz) {
                vy = -sz * 10 - 150;
                if (vy < -500) vy = -500;
                y = 410 - sz;
                if (kind < 0 && (kind -= 10) < -50) return;
            }

            if (x < sz) vx = -vx, x = sz;
            if (x > 640 - sz) vx = -vx, x = 640 - sz;

            obj[0] = x;
            obj[1] = y;
            obj[2] = vx;
            obj[3] = vy;
            obj[4] = kind;
            return true;
        }).concat(newobjs);

        harpoons = harpoons.filter(
            harpoon => !harpoon[2] && (harpoon[1] -= 400 * elapsed) > -4);
    }

    canvas.width |= 0;

    context.textAlign = 'center';
    context.textBaseline = 'middle';
    drawtext(320, 240, '900 100', '#fff', level || 'Enter to start', 'blur(3px');

    canvas.style.background = `linear-gradient(0, #ada996 ${0+Math.abs(Math.sin(now))*5}%, #f7e6d6 13.8%, #bbd2d8 13.8%, #66deff 15%, #57f3ff ${30+Math.cos(now)*5}%, #01a4c9 ${80+Math.cos(now)*10}%`;
    objs.forEach(drawobj);
    harpoons.forEach(([x, top]) =>
        drawtext(x, top, 8, '#c09e3f', 'üî±') |
        context.fillRect(x - 1, top, 2, 410 - top));
    drawobj([playerx, 390, -playervx, 0, 1, 'üßúüèΩ‚Äç‚ôÇÔ∏è']);
};
tick(0);
</script>
