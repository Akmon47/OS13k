<html lang=en>
<body bgcolor=black onkeydown=keydown[event.keyCode]=lastnow onkeyup=keydown[event.keyCode]=0>
<canvas id=canvas width=640 height=480></canvas>
<script>
context = canvas.getContext`2d`;

lastnow =
level =
life =
playervx =
slowuntil =
multiuntil =
graceuntil = 0;

playerx = 320;

keydown = {};
objs = harpoons = []; // doesn't change when level=0 and reset at start, so can be shared

drawobj = ([x, y, vx, , kind, text]) => {
    context.save();
    vx > 0 && context.transform(-1, 0, 0, 1, x*2, 0);
    sz = Math.max(kind, 0) * 20 + 20;
    context.font = sz + 'px a';
    if (text) { // player, possibly with effects
        filter = '';
        if (life) filter = 'drop-shadow(0px 0px 10px white) drop-shadow(2px 2px 2px white)';
        if (lastnow < multiuntil) filter += ' drop-shadow(2px 4px 6px orange';
        context.filter = filter;
    } else {
        // ordinary objs: first 10 characters (all ex-BMP, i.e. two units in JS)
        // bonus objs: last 3 characters (plus some ZWSP to pad to two units)
        text = 'ü¶êüê°üê†üêüüêôü¶ëüê¨üê≥üêãü¶à‚è∞‚Äã‚≠ê‚Äãüíù'.substr(kind % 10 * 2, 2);
    }
    context.fillText(text, x, y);
    context.restore();
};

tick = now => {
    now /= 1e3;
    requestAnimationFrame(tick); // update can fail, so we must enqueue beforehand

    // our collision check is primitive, so we need to ensure the minimum frame rate
    elapsed = Math.min(now - lastnow, 100);
    harpoonshot = keydown[32] == lastnow;
    lastnow = now;

    if (level || keydown[13]) {
        // enter to start (also actual reset)
        if (!level) {
            canvas.style.filter = '';
            life = playervx = slowuntil = multiuntil = 0;
            playerx = 320;
            objs = [];
            harpoons = [];
            keydown = {}; // no pre-press advantage :-)
        }

        // if all remaining objects are bonuses (or none)
        if (objs.every(obj => obj[4] < 0)) {
            template = [
                [[0, 1]],
                [[1, 1]],
                [[0, 2], [2, 1]],
                [[2, 3]],
                [[1, 4], [3, 1]],
                [[3, 2]],
                [[0, 9]],
            ][level % 7];
            for ([kind, count] of template) {
                for (i = 0; i < count; ++i) {
                    objs.push([
                        640 * (i + 1) / (count + 1),
                        kind * 10 + 10,
                        100,
                        0,
                        kind + (level / 7 | 0),
                    ]);
                }
            }
            ++level;
        }

        playervx = (!keydown[37] - !keydown[39]) * 300;
        playerx = Math.min(Math.max(playerx + playervx * elapsed, 20), 620);

        // shot harpoon if no other harpoon exists or multi is enabled
        if (harpoonshot && (!harpoons[0] || now < multiuntil)) {
            harpoons.push([playerx + (playervx > 0 ? 6 : -6), 410]);
        }

        objelapsed = elapsed * (now < slowuntil ? .3 : 1);
        newobjs = [];
        objs = objs.filter(obj => {
            ([x, y, vx, vy, kind] = obj);
            vy += 600 * objelapsed;
            sz = Math.max(kind, 0) * 10 + 10; // so that (x, y) +/- sz is occupied by obj

            // against harpoons (for ordinary objs)
            if (kind >= 0) {
                lextent = x - sz + Math.min(vx * objelapsed, 0);
                rextent = x + sz + Math.max(vx * objelapsed, 0);
                for (harpoon of harpoons) {
                    ([hx, htop, used] = harpoon);
                    if (!used && y > htop && lextent < hx && hx < rextent) {
                        // larger obj generates a pair of smaller objs when popped
                        if (kind) {
                            newobjs.push(
                                [x, y, vx, -350, kind - 1],
                                [x, y, -vx, -350, kind - 1]);
                        }
                        // 10% chance of additional bonus objs
                        if (Math.random() < .1) {
                            newobjs.push([x, y, vx, vy, Math.random() * 3 - 4 | 0]);
                        }
                        harpoon[2] = 1; // so that harpoon will be cleared off
                        return; // and this elimiates the original obj
                    }
                }
            }

            // against player
            if ((x - playerx)**2 + (y - 390)**2 < sz**2 + 20**2) {
                if (kind < 0) {
                    kind %= 10;
                    if (kind == -1) life = 1;
                    if (kind == -2) multiuntil = now + 10;
                    if (kind == -3) slowuntil = now + 10;
                    return;
                }
                // game is over when life was already 0 and grace period expires
                if (life) {
                    life = 0;
                    graceuntil = now + 1;
                } else if (now > graceuntil) {
                    // we can't reset right now, as drawing still happens every frame
                    // the actual reset will happen on enter
                    canvas.style.filter = 'invert(1';
                    level = 0;
                    throw 1; // this "tick" can't be continued
                }
            }

            x += vx * objelapsed;
            y += vy * objelapsed;

            // against ground
            if (y > 410 - sz) {
                vy = Math.max(-500, -sz * 10 - 150);
                y = 410 - sz;
                if (kind < 0 && (kind -= 10) < -50) return;
            }

            if (x < sz) vx = -vx, x = sz;
            if (x > 640 - sz) vx = -vx, x = 640 - sz;

            obj[0] = x;
            obj[1] = y;
            obj[2] = vx;
            obj[3] = vy;
            obj[4] = kind;
            return true;
        }).concat(newobjs);

        harpoons = harpoons.filter(harpoon => {
            return !harpoon[2] && (harpoon[1] -= 400 * elapsed) > -4;
        });
    }

    canvas.width |= 0;

    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.save();
    context.font = '900 100px a';
    context.fillStyle = '#fff';
    context.filter = 'blur(3px)';
    context.fillText(level || 'Enter to start', 320, 240);
    context.restore();

    canvas.style.background = `linear-gradient(0, #ada996 ${0+Math.abs(Math.sin(now))*5}%, #f7e6d6 13.8%, #bbd2d8 13.8%, #66deff 15%, #57f3ff ${30+Math.cos(now)*5}%, #01a4c9 ${80+Math.cos(now)*10}%`;
    objs.forEach(drawobj);
    harpoons.forEach(([x, top]) => {
        context.font = '8px a';
        context.fillStyle = '#c09e3f';
        context.fillText('üî±', x, top);
        context.fillRect(x - 1, top, 2, 410 - top);
    });
    drawobj([playerx, 390, -playervx, 0, 1, 'üßúüèΩ‚Äç‚ôÇÔ∏è']);
};
tick(0);
</script>
