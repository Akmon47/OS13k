<html lang=en>
<body bgcolor=#000 onkeydown=keydown[event.keyCode]=lastnow onkeyup=keydown[event.keyCode]=0>
<canvas id=C width=640 height=480>
<script>
// the following preamble is included as is:
with(Math)with(C.getContext`2d`){

// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @language_out ECMASCRIPT_2019
// @js_externs C, requestAnimationFrame, Q
// @js_externs sin, cos, random, min, max
// @js_externs font, textAlign, textBaseline, fliter, fillStyle, fillText, fillRect, save, transform, restore
// @output_file_name aquapop.min.js
// ==/ClosureCompiler==

var lastnow, level, life, playerx, playervx, slowuntil, multiuntil, graceuntil;
var keydown, objs, harpoons;
var drawtext, drawobj, tick;

lastnow = 0;
level =
life =
playervx =
slowuntil =
multiuntil =
graceuntil = 0;

playerx = 320;

keydown = {};
objs = harpoons = []; // doesn't change when level=0 and reset at start, so can be shared

drawtext = (x, y, sz, fill, text, textfilter) => { // textfilter optional
    font = sz + 'px a';
    filter = textfilter; // nothing happens if undefined
    fillStyle = fill;
    fillText(text, x, y);
    filter = 'none';
};

tick = now => {
    now /= 1e3;
    requestAnimationFrame(tick); // update can fail, so we must enqueue beforehand

    // our collision check is primitive, so we need to ensure the minimum frame rate
    var elapsed = now - lastnow < 100 ? now - lastnow : 100;
    var harpoonshot = keydown[32] == lastnow;
    lastnow = now;

    if (level || keydown[13]) {
        // enter to start (also actual reset)
        if (!level) {
            C.style.filter = '';
            life = playervx = slowuntil = multiuntil = graceuntil = 0;
            playerx = 320;
            objs = [];
            harpoons = [];
            keydown = {}; // no pre-press advantage :-)
        }

        // if all remaining objects are bonuses (or none)
        if (objs.every(obj => obj[4] < 0)) {
            // encoded%4 encodes kind, encoded%11 encodes count+1.
            // if there are more kind-count pairs encoded is shifted right by 6 bits.
            // (note that this does change mod 4/11, encoder accounts for this)
            //
            // A,B,D,F,G=[min(i for i in range(44) if i%4==a and i%11==b) for a,b in [(0,2),(1,2),(2,4),(3,3),(0,10)]]
            // C,E=[min(i for i in range(4*11*64) if (i%4,i%11,(i>>6)%4,(i>>6)%11) in ((a,b+1,c,d+1), (c,d+1,a,b+1))) for a,b,c,d in [(2,1,0,2),(1,4,3,1)]]
            // print(A,B,C,D,E,F,G)
            for (var encoded = [24,13,168,26,343,3,32][level % 7], i; encoded; encoded >>= 6)
                for (i = encoded % 11 - 1; i; objs.push([
                    640 * i-- / (encoded % 11),
                    encoded % 4 * 10 + 10,
                    100,
                    0,
                    encoded % 4 + level / 7 | 0,
                ]));
            ++level;
        }

        playervx = (!keydown[37] - !keydown[39]) * 300;
        playerx += playervx * elapsed;
        playerx = playerx < 20 ? 20 : playerx > 620 ? 620 : playerx;

        // shot harpoon if no other harpoon exists or multi is enabled
        if (harpoonshot && (!harpoons[0] || now < multiuntil))
            harpoons.push([playerx + (playervx > 0 ? 6 : -6), 410]);

        var objelapsed = now < slowuntil ? elapsed * .3 : elapsed;
        var newobjs = [];
        objs.map(([x, y, vx, vy, kind], sz, rand) => (
            vy += 600 * objelapsed,
            sz = (kind > 0) * kind * 10 + 10, // so that (x, y) +/- sz is occupied by obj

            // 1. for ordinary objs, collision check against harpoons
            kind >= 0 &&
            harpoons.some(harpoon =>
                // harpoon == [hx, htop] & {u: used}
                !harpoon.u &&
                y > harpoon[1] &&
                x - sz + (vx < 0) * vx * objelapsed < harpoon[0] &&
                x + sz + (vx > 0) * vx * objelapsed > harpoon[0] && (
                    kind && [vx, -vx].map(vx => newobjs.push([x, y, vx, -350, kind - 1])),
                    rand = random(),
                    rand < .1 && newobjs.push([x, y, vx, vy, rand * 30 - 4 | 0]),
                    harpoon.u = 1 // this is also a return value for harpoons.some
            ))

        ) || (

            // 2. collision check against player, if harpoons didn't hit the obj
            // (marked as "<return>" is a return value for deletecur)
            (x - playerx)**2 + (y - 390)**2 < sz * sz + 20**2 && (
                kind < 0 ?
                    (
                        kind %= 10,
                        // <return>
                        ++kind ? // kind != -1
                            ++kind ? // kind != -1 or -2
                                slowuntil = now + 10 : // kind == -3
                                multiuntil = now + 10 : // kind == -2
                            life = 1 // kind == -1
                        // </return>
                    )
                // game is over when life was already 0 and grace period expires
                : life ? (
                    graceuntil = now + 1,
                    life = 0 // <return>
                ) : now > graceuntil ? (
                    // we can't reset right now, as drawing still happens every frame
                    // the actual reset will happen on enter
                    C.style.filter = 'invert\(1',
                    level = 0,
                    Q() // this "tick" can't be continued; this is a way to break out
                ) : 0 // <return>
            )

        ) || (

            // 3. move surviving objects
            x += vx * objelapsed,
            x < sz ? (vx = -vx, x = sz) :
            x > 640 - sz && (vx = -vx, x = 640 - sz),

            y += vy * objelapsed,
            y > 410 - sz && ( // collision check against ground
                y = 410 - sz,
                vy = max(-sz * 10 - 150, -500),
                kind -= kind < 0 ? 10 : 0
            ),

            kind > -50 && newobjs.push([x, y, vx, vy, kind])

        ));
        objs = newobjs;

        harpoons = harpoons.filter(
            harpoon => !harpoon.u && (harpoon[1] -= 400 * elapsed) > -4);
    }

    C.width |= 0;

    textAlign = 'center';
    textBaseline = 'middle';
    drawtext(320, 240, '900 100', '#fff', level || 'Enter to start', 'blur\(3px');

    C.style.background = `linear-gradient(0,#ada996 ${abs(sin(now))*5}%,#f7e6d6 13.8%,#bbd2d8 13.8%,#66deff 15%,#57f3ff ${30+cos(now)*5}%,#01a4c9 ${80+cos(now)*10}%`;
    objs.map(drawobj = ([x, y, vx, , kind, text]) => {
        save();
        vx > 0 && transform(-1, 0, 0, 1, x*2, 0);
        drawtext(
            x,
            y,
            (kind > 0) * kind * 20 + 20,
            0,
            text || '🦐🐡🐠🐟🐙🦑🐬🐳🐋🦈⏰​⭐​💝'.substr(kind % 10 * 2, 2),
            text ?
                (life ? 'drop-shadow(0 0 10px #fff) drop-shadow(2px 2px 2px #fff)' : '') +
                (lastnow < multiuntil ? ' drop-shadow\(2px 4px 6px orange' : '') :
            0);
        restore();
    });
    harpoons.map(([x, top]) =>
        drawtext(x, top, 8, '#c09e3f', '🔱') |
        fillRect(x - 1, top, 2, 410 - top));
    drawobj([playerx, 390, -playervx, 0, 1, '🧜🏽‍♂️']);
};
tick(0);

// end of closure input
}
</script>
